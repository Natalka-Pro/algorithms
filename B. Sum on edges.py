"""
Вася взял игральную кость и написал на гранях числа a1, a2, a3, a4, a5 и a6.
Для генерации случайного числа Вася решил воспользоваться следующим алгоритмом:
Выбрать число k
Подбросить кубик k раз и записать на листик последовательно выпавших чисел b_j
Пройтись по списку с конца и вычеркнуть число b_j, если оно равно b_(j-1)
(b_j всегда останется в последовательности).
Определите математическое ожидание суммы оставшихся в последовательности чисел,
если Вася сообщит вам числа a_i и k.
Обратите внимание, что кубик у Васи честный и все выпадение любой из граней равновероятно.
Кроме этого, подбрасывания кубика независимы.

Формат ввода
В первой строке записаны 6 целых чисел a1, a2, a3, a4, a5 и a6 (1 <= a_i <= 1000).
Во второй строке записано одно число k (1≤k≤1000).

Формат вывода
Выведите одно вещественное число — требуемое по условию задачи математическое ожидание.
Ответ будет считаться верным, если относительная или абсолютная погрешность не будет
превышать 1e-6.

Пример 1
Ввод
Вывод
1 2 3 4 5 6
2

6.4166666667

Пример 2
Ввод
Вывод
1 1 1 1 1 1
3

1.0000000000

Пример 3
Ввод
Вывод
1 2 1 2 2 2
2

2.3333333333

Примечания
В первом примере из 36 возможных исходов в 6 будет вычеркнуто повторяющееся число.
Во втором примере возможна единственная последовательность 2 2 2, после вычеркивания
двух двоек длина последовательности станет равной одному.

https://ru.stackoverflow.com/questions/1581482/%D0%9F%D1%80%D0%BE%D1%88%D1%83-%D0%BF%D0%BE%D0%BC%D0%BE%D1%87%D1%8C-%D1%81-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8-%D1%81%D0%BE-%D1%81%D1%82%D0%B0%D1%80%D0%BE%D0%B3%D0%BE-%D0%AF%D0%BD%D0%B4%D0%B5%D0%BA%D1%81-%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D1%81%D1%82%D0%B0
"""

A, K = list(map(int, input().split())), int(input())
denominator = 6**K

count_dict = {}

for a_i in A:
    if a_i not in count_dict:
        count_dict[a_i] = 0

    count_dict[a_i] += 1

num_a = len(count_dict)
keys_a = list(count_dict.keys())
count_a = list(count_dict.values())
# print(A)

s_ka = [[0] * num_a for _ in range(K)]

for i in range(num_a):
    s_ka[0][i] = keys_a[i]


def sum_with_weights(s, w):
    ans = 0
    for i, j in zip(s, w):
        ans += i * j
    return ans


for k in range(1, K):
    for i, a_i in enumerate(keys_a):
        pred = sum_with_weights(s_ka[k - 1], count_a)
        # print(pred, a_i, 6 - count_a[i])
        s_ka[k][i] = pred + a_i * (6 - count_a[i]) * 6 ** (k - 1)

print(sum_with_weights(s_ka[K - 1], count_a) / denominator)


# a, k = A, K

# c = 1
# s = a
# for _ in range(1, k):
#     s_next = [0] * len(a)
#     for i in range(len(a)):
#         for j in range(len(a)):
#             s_next[i] += s[j]
#             if a[j] != a[i]:
#                 s_next[i] += a[i] * c
#     c *= len(a)
#     s = s_next

# print(sum(s) / (len(a) * c))
