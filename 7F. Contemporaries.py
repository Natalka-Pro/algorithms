"""
Группа людей называется современниками, если был такой момент, когда они могли собраться
все вместе и обсуждать какой-нибудь важный вопрос. Для этого в тот момент, когда
они собрались, каждому из них должно было уже исполниться 18 лет, но еще не исполниться
80 лет.
Вам дан список великих людей с датами их жизни. Выведите всевозможные максимальные
множества современников. Множество современников будем называть максимальным, если
нет другого множества современников, которое включает в себя всех людей из первого
множества.
Будем считать, что в день своего 18-летия человек уже может принимать участие в
такого рода собраниях, а в день 80-летия, равно как и в день своей смерти, — нет.

Формат ввода
Сначала на вход программы поступает число N — количество людей (1 ≤ N ≤ 10000).
Далее в N строках вводится по шесть чисел — первые три задают дату (день, месяц,
год) рождения, следующие три — дату смерти (она всегда не ранее даты рождения).
День (в зависимости от месяца, а в феврале — еще и года) от 1 до 28, 29, 30 или
31, месяц — от 1 до 12, год — от 1 до 2005.

Формат вывода
Программа должна вывести все максимальные множества современников. Каждое множество
должно быть записано на отдельной строке и содержать номера людей (люди во входных
данных нумеруются в порядке их задания, начиная с 1). Номера людей должны разделяться
пробелами.
Никакое множество не должно быть указано дважды.
Если нет ни одного непустого максимального множества, выведите одно число 0.
Гарантируется, что входные данные будут таковы, что размер выходных данных для правильного
ответа не превысит 2 Мб.

Пример 1
Ввод
Вывод
3
2 5 1988 13 11 2005
1 1 1 1 1 30
1 1 1910 1 1 1990

2
3

Пример 2
Ввод
Вывод
3
2 5 1968 13 11 2005
1 1 1 1 1 30
1 1 1910 1 1 1990

2
1 3

Пример 3
Ввод
Вывод
3
2 5 1988 13 11 2005
1 1 1 1 1 10
2 1 1910 1 1 1928

0
"""

IN = 1
OUT = -1


def find_adulthood(dmy_birth, dmy_death):
    y, m, d = dmy_birth
    dmy_18 = (y + 18, m, d)
    dmy_80 = (y + 80, m, d)

    return min(dmy_18, dmy_death), min(dmy_80, dmy_death)


def fun(segments):
    """
    >>> fun([(2, 5, 1988, 13, 11, 2005), (1, 1, 1, 1, 1, 30), (1, 1, 1910, 1, 1, 1990)])
    [{2}, {3}]
    >>> fun([(2, 5, 1968, 13, 11, 2005), (1, 1, 1, 1, 1, 30), (1, 1, 1910, 1, 1, 1990)])
    [{2}, {1, 3}]
    >>> fun([(2, 5, 1988, 13, 11, 2005), (1, 1, 1, 1, 1, 10), (2, 1, 1910, 1, 1, 1928)])
    0
    """

    # N = len(segments)
    events = []

    for i, (d1, m1, y1, d2, m2, y2) in enumerate(segments):

        start, end = find_adulthood((y1, m1, d1), (y2, m2, d2))
        # start, end = (y1, m1, d1), (y2, m2, d2)
        if start != end:
            events.append((start, IN, i + 1))
            events.append((end, OUT, i + 1))

    events.sort()
    # print(*events, sep="\n")

    if len(events) == 0:
        return 0

    num = 0
    ans = [set()]  # для хранения современников
    wait_another = set()

    for i in range(len(events)):
        _, type, person = events[i]

        if type == IN:
            num += 1

            if len(wait_another) == 0:
                ans[-1].add(person)
            else:
                ans.append(wait_another.copy())
                ans[-1].add(person)

            # print(person, num, ans)

        elif type == OUT:
            num -= 1
            if num == 0:
                ans.append(set())
            else:
                if len(wait_another) == 0:
                    # print("new wait_another")
                    wait_another = ans[-1].copy()

                # print(11, wait_another, ans[-1], id(wait_another), id(ans[-1]))
                wait_another.remove(person)
                # print(22, wait_another, ans[-1], id(wait_another), id(ans[-1]))

            # print(person, num, ans)

    return ans[:-1]


N = int(input())
s = [tuple(map(int, input().split())) for _ in range(N)]
ans = fun(s)
if ans == 0:
    print(0)
else:
    for i in ans:
        print(*i)

# print(f">>> fun({s})")
# print(f"    {fun(s)}")

# print(fun([(1, 1, 100, 1, 1, 2000), (1, 1, 100, 1, 1, 200),
#            (1, 1, 150, 1, 1, 1900), (1, 1, 300, 1, 1, 3000)]))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
