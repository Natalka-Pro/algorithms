"""
Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый
следующий элемент больше либо равен предыдущему), в каждой из последовательностей
ровно L элементов. Для каждых двух последовательностей выполняют следующую операцию:
объединяют их элементы (в объединенной последовательности каждое число будет идти
столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях),
упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности
из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).
Напишите программу, которая для каждой пары последовательностей выведет левую медиану
их объединения.

Формат ввода
Сначала вводятся числа N и L (2 ≤ N ≤ 200, 1 ≤ L ≤ 50000). В следующих N строках
задаются параметры, определяющие последовательности.
Каждая последовательность определяется пятью целочисленными параметрами: x1, d1,
a, c, m. Элементы последовательности вычисляются по следующим формулам: x1 нам задано,
а для всех i от 2 до L: xi = xi–1+di–1. Последовательность di определяется следующим
образом: d1 нам задано, а для i ≥ 2 di = ((a*di–1+c) mod m), где mod – операция
получения остатка от деления (a*di–1+c) на m.
Для всех последовательностей выполнены следующие ограничения: 1 ≤ m ≤ 40000, 0 ≤
a < m, 0≤c<m, 0≤d1<m. Гарантируется, что все члены всех последовательностей по модулю
не превышают 109.

Формат вывода
В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй
строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й
и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д.
до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена
медиана объединения (N–1)-й и N-ой последовательностей.

Пример
Ввод
Вывод
3 6
1 3 1 0 5
0 2 1 1 100
1 6 8 5 11

7
10
9

Примечания
Последовательности, объединения которых мы считаем, таковы:
1 4 7 10 13 16
0 2 5 9 14 20
1 7 16 16 21 22
"""


def seq_full(l, x1, d1, a, c, m):
    seq = [x1]
    d = d1
    for _ in range(l - 1):
        seq.append(seq[-1] + d)
        d = (a * d + c) % m
    return seq


def lfind(l, r, check, params):
    while l < r:
        m = (l + r) // 2
        if check(m, params):
            r = m
        else:
            l = m + 1

    return l


def check(index, params):
    s, x = params
    return s[index] >= x


def cntless(s, x):
    ans = lfind(0, len(s) - 1, check, (s, x))

    if s[ans] < x:
        return len(s)
    return ans


def cntgt(s, x):
    return len(s) - cntless(s, x + 1)


def median_bin(s1, s2):

    l = min(s1[0], s2[0])
    r = max(s1[-1], s2[-1])

    L = len(s1)

    while l < r:
        m = (l + r) // 2

        less = cntless(s1, m) + cntless(s2, m)
        great = cntgt(s1, m) + cntgt(s2, m)

        if less <= L - 1 and great <= L:
            return m
        elif less >= L:
            r = m - 1
        elif great > L:
            l = m + 1

    return l


def fun(s, L):
    """
    TL - 14 test

    >>> fun([[1, 3, 1, 0, 5], [0, 2, 1, 1, 100], [1, 6, 8, 5, 11]], 6)
    [7, 10, 9]
    """

    ans = []

    for i in range(len(s)):
        for j in range(i + 1, len(s)):
            ans.append(median_bin(seq_full(L, *s[i]), seq_full(L, *s[j])))

    return ans


N, L = map(int, input().split())
# s = [list(map(int, input().split())) for _ in range(N)]
# print(*fun(s, L), sep="\n")
# TL - 14 test !!!

s = []
for i in range(N):
    x1, d1, a, c, m = map(int, input().split())
    s.append(seq_full(L, x1, d1, a, c, m))

# ans = []
for i in range(len(s)):
    for j in range(i + 1, len(s)):
        print(median_bin(s[i], s[j]))
# print(*ans, sep="\n")


# print(f">>> fun({s}, {L})")
# print(f"    {fun(s, L)}")


if __name__ == "__main__":
    import doctest

    doctest.testmod()
