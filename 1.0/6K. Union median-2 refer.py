"""
Дано N упорядоченных по неубыванию последовательностей целых чисел (т.е. каждый
следующий элемент больше либо равен предыдущему), в каждой из последовательностей
ровно L элементов. Для каждых двух последовательностей выполняют следующую операцию:
объединяют их элементы (в объединенной последовательности каждое число будет идти
столько раз, сколько раз оно встречалось суммарно в объединяемых последовательностях),
упорядочивают их по неубыванию и смотрят, какой элемент в этой последовательности
из 2L элементов окажется на месте номер L (этот элемент называют левой медианой).
Напишите программу, которая для каждой пары последовательностей выведет левую медиану
их объединения.

Формат ввода
Сначала вводятся числа N и L (2 ≤ N ≤ 200, 1 ≤ L ≤ 50000). В следующих N строках
задаются параметры, определяющие последовательности.
Каждая последовательность определяется пятью целочисленными параметрами: x1, d1,
a, c, m. Элементы последовательности вычисляются по следующим формулам: x1 нам задано,
а для всех i от 2 до L: xi = xi–1+di–1. Последовательность di определяется следующим
образом: d1 нам задано, а для i ≥ 2 di = ((a*di–1+c) mod m), где mod – операция
получения остатка от деления (a*di–1+c) на m.
Для всех последовательностей выполнены следующие ограничения: 1 ≤ m ≤ 40000, 0 ≤
a < m, 0≤c<m, 0≤d1<m. Гарантируется, что все члены всех последовательностей по модулю
не превышают 109.

Формат вывода
В первой строке выведите медиану объединения 1-й и 2-й последовательностей, во второй
строке — объединения 1-й и 3-й, и так далее, в (N‑1)-ой строке — объединения 1-й
и N-ой последовательностей, далее медиану объединения 2-й и 3-й, 2-й и 4-й, и т.д.
до 2-й и N-ой, затем 3-й и 4-й и так далее. В последней строке должна быть выведена
медиана объединения (N–1)-й и N-ой последовательностей.

Пример
Ввод
Вывод
3 6
1 3 1 0 5
0 2 1 1 100
1 6 8 5 11

7
10
9

Примечания
Последовательности, объединения которых мы считаем, таковы:
1 4 7 10 13 16
0 2 5 9 14 20
1 7 16 16 21 22
"""


def gensequence(l, x1, d1, a, c, m):
    seq = [x1]
    d = d1
    for _ in range(l - 1):
        seq.append(seq[-1] + d)
        d = (a * d + c) % m
    return seq


def lbinsearch(l, r, check, checkparams):
    while l < r:
        m = (l + r) // 2
        if check(m, checkparams):
            r = m
        else:
            l = m + 1
    return l


def checkisge(index, params):
    seq, x = params
    return seq[index] >= x


# def checkisgt(index, params):
#     seq, x = params
#     return seq[index] > x


def cntless(seq, x):
    ans = lbinsearch(0, len(seq) - 1, checkisge, (seq, x))
    if seq[ans] < x:
        return len(seq)
    return ans


def cntgt(seq, x):
    return len(seq) - cntless(seq, x + 1)


def medianmerge(seq1, seq2):
    l = min(seq1[0], seq2[0])
    r = max(seq1[-1], seq2[-1])

    while l < r:
        m = (l + r) // 2
        less = cntless(seq1, m) + cntless(seq2, m)
        gt = cntgt(seq1, m) + cntgt(seq2, m)
        if less <= len(seq1) - 1 and gt <= len(seq1):
            return m
        if gt > len(seq1):
            l = m + 1
        if less > len(seq1) - 1:
            r = m - 1
    return l


n, l = map(int, input().split())
seqs = []
for i in range(n):
    x1, d1, a, c, m = map(int, input().split())
    seqs.append(gensequence(l, x1, d1, a, c, m))

for i in range(n):
    for j in range(i + 1, n):
        print(medianmerge(seqs[i], seqs[j]))
