"""
Над ареной огромного спортивного комплекса Независимого Главного Университета (НГУ)
решили построить перекрытие. Перекрытие будет построено по клеевой технологии и
состоять из склеенных друг с другом блоков. Блок представляет собой легкий прямоугольный
параллелепипед. Два блока можно склеить, если они соприкасаются перекрывающимися
частями боковых граней ненулевой площади.
НГУ представил план комплекса, имеющий вид прямоугольника размером W на L. При этом
один из углов прямоугольника находится в начале системы координат, а другой имеет
координаты (W, L). Стены комплекса параллельны осям координат.
Подрядчики известили НГУ, что они готовы к определенному сроку изготовить блоки
и установить их. Для каждого блока фиксировано место его возможного монтажа, совпадающее
по размерам с этим блоком. Места выбраны так, что ребра блоков параллельны осям
координат. Места монтажа блоков не пересекаются.
По техническим условиям перекрытие должно состоять из такого набора склеенных блоков,
который содержит сплошной горизонтальный слой ненулевой толщины. Торопясь ввести
комплекс в эксплуатацию, НГУ решил построить перекрытие из минимально возможного
числа блоков.
Требуется написать программу, которая позволяет выбрать минимальное число блоков,
которые, будучи установленными на указанных подрядчиками местах, образуют перекрытие,
либо определить, что этого сделать невозможно. Высота, на которой образуется перекрытие,
не имеет значения.

Формат ввода
В первой строке входного файла указаны три целых числа: N — количество возможных
блоков (1 ≤ N ≤ 105) и размеры комплекса W и L (1 ≤ W, L ≤ 104). Каждая из последующих
N строк описывает место монтажа одного блока, определяемое координатами противоположных
углов: (x1, y1, z1) и (x2, y2, z2), при этом 0 ≤ x1 < x2 ≤ W, 0 ≤ y1 < y2 ≤ L, 0
≤ z1 < z2 ≤ 109. Все числа во входном файле целые и разделяются пробелами или переводами
строк.
Гарантируется, что места установки блоков не пересекаются друг с другом.

Формат вывода
Первая строка выходного файла должна содержать либо слово «YES», если перекрытие
возможно построить, иначе — слово «NO». В первом случае вторая строка выходного
файла должна содержать минимальное число блоков, образующих перекрытие, а последующие
строки — номера этих блоков, в соответствии с порядком, в котором они перечислены
во входном файле.
Если возможно несколько минимальных наборов блоков, выведите любой из них.

Пример 1
Ввод
Вывод
1 10 10
0 0 0 10 10 10

YES
1
1

Пример 2
Ввод
Вывод
2 10 10
0 0 0 10 5 5
0 5 5 10 10 10

NO
"""

IN = 1
OUT = -1 
# чтобы нулевое пересечение не посчитать


def fun(N, W, L):
    # OK - 0.649s 42.48Mb
    # в худшем случае квадратичная сложность из-за копирования множества

    TOTAL_SQUARE = W * L
    events = []

    for i in range(N):
        x1, y1, z1, x2, y2, z2 = map(int, input().split())
        # (time, type, square, idx)
        events.append((z2, OUT, (y2 - y1) * (x2 - x1), i+1))
        events.append((z1, IN, (y2 - y1) * (x2 - x1), i+1))

    cur_square = 0 # есть покрытие => площадь при фиксированном z == полной
    cur_blocks = set()
    best_blocks = set()

    events.sort()

    for _, type, square, idx in events:
        if type == IN:
            cur_square += square
            cur_blocks.add(idx)

        if type == OUT:
            cur_square -= square
            cur_blocks.remove(idx)

        if cur_square == TOTAL_SQUARE and (len(best_blocks) == 0 or len(cur_blocks) < len(best_blocks)):
            best_blocks = cur_blocks.copy()

        
    if len(best_blocks) == 0:
        return ["NO"]
    
    ans = ["YES", len(best_blocks)]

    for elem in list(best_blocks):
        ans.append(elem)

    return ans


def fun(N, W, L):
    # OK - 0.648s 38.61Mb
    # за два прохода по events

    TOTAL_SQUARE = W * L
    events = []

    for i in range(N):
        x1, y1, z1, x2, y2, z2 = map(int, input().split())
        # (time, type, square, idx)
        events.append((z2, OUT, (y2 - y1) * (x2 - x1), i+1))
        events.append((z1, IN, (y2 - y1) * (x2 - x1), i+1))

    events.sort()

    cur_square = 0 # есть покрытие => площадь при фиксированном z == полной
    cur_num_blocks = 0 # можно хранить количество, а не множество (выигрыш по памяти)
    best_num_blocks = N + 1

    for _, type, square, idx in events:
        if type == IN:
            cur_square += square
            cur_num_blocks += 1

        if type == OUT:
            cur_square -= square
            cur_num_blocks -= 1

        if cur_square == TOTAL_SQUARE and cur_num_blocks < best_num_blocks:
            # best_blocks = cur_blocks.copy()
            best_num_blocks = cur_num_blocks

    if best_num_blocks == N + 1:
        return ["NO"]
    

    cur_square = 0
    best_blocks = set()

    for _, type, square, idx in events:
        if type == IN:
            cur_square += square
            best_blocks.add(idx)

        if type == OUT:
            cur_square -= square
            best_blocks.remove(idx)

        if cur_square == TOTAL_SQUARE and len(best_blocks) == best_num_blocks:
            break


    ans = ["YES", len(best_blocks)]

    for elem in list(best_blocks):
        ans.append(elem)

    return ans


N, W, L = map(int, input().split())
print(*fun(N, W, L), sep="\n")
