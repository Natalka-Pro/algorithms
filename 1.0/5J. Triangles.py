"""
Петя достаточно давно занимается в математическом кружке, поэтому он уже успел не
только правила выполнения простейших операций, но и такое достаточно сложное понятие
как симметрия. Для того, чтобы получше изучить симметрию Петя решил начать с наиболее
простых геометрических фигур – треугольников. Он скоро понял, что осевой симметрией
обладают так называемые равнобедренные треугольники. Поэтому теперь Петя ищет везде
такие треугольники.
Напомним, что треугольник называется равнобедренным, если его площадь положительна,
и у него есть хотя бы две равные стороны.
Недавно Петя, зайдя в класс, увидел, что на доске нарисовано n точек. Разумеется,
он сразу задумался, сколько существует троек из этих точек, которые являются вершинами
равнобедренных треугольников.
Требуется написать программу, решающую указанную задачу.

Формат ввода
Входной файл содержит целое число n (3 ≤ n ≤ 1500). Каждая из последующих строк
содержит по два целых числа – xi и yi – координаты i-ой точки. Координаты точек
не превосходят 109 по абсолютной величине. Среди заданных точек нет совпадающих.

Формат вывода
В выходной файл выведите ответ на задачу.

Пример 1
Ввод
Вывод
3
0 0
2 2
-2 2

1

Пример 2
Ввод
Вывод
4
0 0
1 1
1 0
0 1

4
"""


def shifted_points(points, O):
    mas = [None] * len(points)  # Массив длин

    dubls = 0
    s = set()
    for i, p in enumerate(points):
        x, y = p[0] - O[0], p[1] - O[1]
        l = x**2 + y**2
        # if y < 0:
        #     y = -y
        # elif y == 0 and x < 0:
        #     x = -x
        s.add((x, y))
        if (-x, -y) in s:
            dubls += 1

        mas[i] = l  # (l, x, y)

    return mas, dubls


def fun(s):
    """
    >>> fun([(0, 0), (2, 2), (-2, 2)])
    1
    >>> fun([(0, 0), (1, 1), (1, 0), (0, 1)])
    4
    >>> fun([(0, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)])
    8
    """

    ans = 0

    for i in range(len(s)):
        O = s[i]
        points = s[:i] + s[i + 1 :]

        mas, dubls = shifted_points(points, O)
        ans -= dubls

        mas.sort()

        left = right = 0
        while left < len(mas):
            while right < len(mas) and mas[left] == mas[right]:
                right += 1

            n = right - left - 1
            ans += (n + 1) * n // 2
            left = right

        # right = 0
        # for left in range(len(mas)):
        #     while right < len(mas) and mas[left] == mas[right]:
        #         right += 1

        #     ans += right - left - 1

    return ans


N = int(input())
s = [tuple(map(int, input().split())) for _ in range(N)]
print(fun(s))


# print(f">>> fun({s})")
# print(f"    {fun(s)}")


if __name__ == "__main__":
    import doctest

    doctest.testmod()
