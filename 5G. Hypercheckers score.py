"""
Андрей работает судьей на чемпионате по гипершашкам. В каждой игре в гипершашки
участвует три игрока. По ходу игры каждый из игроков набирает некоторое положительное
целое число баллов. Если после окончания игры первый игрок набрал a баллов, второй
— b, а третий c, то говорят, что игра закончилась со счетом a:b:c.
Андрей знает, что правила игры гипершашек устроены таким образом, что в результате
игры баллы любых двух игроков различаются не более чем в k раз.
После матча Андрей показывает его результат, размещая три карточки с очками игроков
на специальном табло. Для этого у него есть набор из n карточек, на которых написаны
числа x1, x2, …, xn. Чтобы выяснить, насколько он готов к чемпионату, Андрей хочет
понять, сколько различных вариантов счета он сможет показать на табло, используя
имеющиеся карточки.
Требуется написать программу, которая по числу k и значениям чисел на карточках,
которые имеются у Андрея, определяет количество различных вариантов счета, которые
Андрей может показать на табло.

Формат ввода
Первая строка входного файла содержит два целых числа: n и k (3 ≤ n ≤ 100000, 1
≤ k ≤ 109).
Вторая строка входного файла содержит n целых чисел x1, x2, …, xn (1 ≤ xi ≤ 109).

Формат вывода
Выходной файл должен содержать одно целое число — искомое количество различных вариантов
счета.

Пример
Ввод
Вывод
5 2
1 1 2 2 3

9

Примечания
В приведенном примере Андрей сможет показать следующие варианты счета: 1:1:2, 1:2:1,
2:1:1, 1:2:2, 2:1:2, 2:2:1, 2:2:3, 2:3:2, 3:2:2. Другие тройки чисел, которые можно
составить с использованием имеющихся карточек, не удовлетворяют заданному условию,
что баллы любых двух игроков различаются не более чем в k = 2 раза.
"""

from collections import defaultdict
from itertools import permutations


def find_vars(N, num_first, more2count):
    """
    1) первый ключ один раз и остальные два по одному разу (без повторов)
    2) первый ключ один раз и остальные два одинаковые (more2count)
    3) первый ключ два раза (num_first >= 2)
    4) первый ключ 3 раза (num_first >= 3)
    """

    ans = (N - 2) * (N - 1) // 2 * 6

    # l_2 = 0
    # for i in range(1, len(keys)):         # TL!!!
    #     if d[keys[i]] >= 2:
    #         l_2 += 1

    ans += more2count * 3

    if num_first >= 2:
        ans += (N - 1) * 3

    if num_first >= 3:
        ans += 1

    return ans


def fun(s, k):
    """
    >>> fun([1, 1, 2, 2, 3], 2)
    9
    >>> fun([1, 1, 2, 2, 3, 3], 2)
    12
    >>> fun([1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8], 2)
    181
    """

    s.sort()
    d = defaultdict(int)
    for i in s:
        d[i] += 1

    s = list(d.keys())  # только уникальные отсортированные карточки

    # сколько карточек в количестве >= 2 между [left+1 и right-1]
    more2count = 0
    ans = 0

    right = 0
    for left in range(len(s)):
        num_left = d[s[left]]
        more2count -= num_left >= 2

        while right < len(s) and s[right] <= s[left] * k:
            more2count += d[s[right]] >= 2
            right += 1

        # print(left, right, s[left], s[right - 1], more2count)

        lenght = right - left
        ans += find_vars(lenght, num_left, more2count)

    return ans


def right_answer(s, k):
    """
    >>> right_answer([1, 1, 2, 2, 3], 2)
    9
    >>> right_answer([1, 1, 2, 2, 3, 3], 2)
    12
    >>> right_answer([1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8], 2)
    181
    """

    s = set(permutations(s, 3))

    for i in s.copy():
        if max(i) > k * min(i):
            s.remove(i)

    return len(s)


_, k = map(int, input().split())
s = list(map(int, input().split()))
print(fun(s, k))


# print(f">>> fun({s}, {k})")
# print(f"    {fun(s, k)}")


# od = OrderedDict()
# od = {}
# for i in range(100, 1, -1):
#     od[i] = i+1
# print(list(od.keys()))


if __name__ == "__main__":
    import doctest

    doctest.testmod()
